#!/usr/bin/env bash

# Create per-project lock file to prevent duplicate instances
# Determine project name based on current working directory
CURRENT_DIR=$(pwd)
parent_dir=$(dirname "$CURRENT_DIR")

if [[ -f "$parent_dir/.bare" ]] || git -C "$parent_dir" rev-parse --is-bare-repository &>/dev/null 2>&1; then
    # We're in a worktree - use bare repo name for lock
    project_name=$(basename "$parent_dir" | sed 's/\.git$//' | tr . _)
elif [[ -f "$CURRENT_DIR/.bare" ]] || git -C "$CURRENT_DIR" rev-parse --is-bare-repository &>/dev/null 2>&1; then
    # We're in the bare repo itself
    project_name=$(basename "$CURRENT_DIR" | sed 's/\.git$//' | tr . _)
else
    # Regular directory - use current directory name for lock
    project_name=$(basename "$CURRENT_DIR" | tr . _)
fi

# Create lock file with project-specific name
LOCK_FILE="/tmp/tmux-sessionizer-${project_name}.lock"
if [[ -f "$LOCK_FILE" ]]; then
    # Another instance for this project is running, exit silently
    exit 0
fi

# Create lock file and ensure cleanup on exit
trap "rm -f '$LOCK_FILE'" EXIT
touch "$LOCK_FILE"

# Function to check if a directory is a bare git repository
is_bare_repo() {
    local dir=$1
    [[ -d "$dir" ]] || return 1
    # Fast check: look for .bare marker file first
    [[ -f "$dir/.bare" ]] && return 0
    # Fallback to git check
    local result=$(git -C "$dir" rev-parse --is-bare-repository 2>/dev/null)
    [[ "$result" == "true" ]]
}

# Function to detect if directory is a git worktree
is_git_repo() {
    local dir=$1
    [[ -d "$dir" ]] || return 1
    git -C "$dir" rev-parse --is-inside-work-tree &>/dev/null
}

# Function to get branch name for a git directory
get_branch() {
    local dir=$1
    git -C "$dir" branch --show-current 2>/dev/null
}

# Function to get all worktrees from a bare repo
get_worktrees_from_bare() {
    local bare_repo=$1
    # Parse git worktree list --porcelain output
    # Skip the bare repo itself, only return actual worktrees
    git -C "$bare_repo" worktree list --porcelain 2>/dev/null | \
        awk '
            /^worktree/ { path = $2; has_path = 1 }
            /^bare$/ { has_path = 0 }
            /^$/ {
                if (has_path) print path
                has_path = 0
            }
            END { if (has_path) print path }
        '
}

# Get last modification time using filesystem (FAST!)
get_dir_mtime() {
    local dir=$1
    # Use stat to get directory modification time (much faster than git log)
    if [[ "$(uname)" == "Darwin" ]]; then
        # macOS
        stat -f "%m" "$dir" 2>/dev/null || echo "0"
    else
        # Linux
        stat -c "%Y" "$dir" 2>/dev/null || echo "0"
    fi
}

# Convert timestamp to "X ago" format
time_ago() {
    local timestamp=$1
    local now=$(date +%s)
    local diff=$((now - timestamp))

    if [[ $diff -lt 60 ]]; then
        echo "${diff}s ago"
    elif [[ $diff -lt 3600 ]]; then
        echo "$((diff / 60))m ago"
    elif [[ $diff -lt 86400 ]]; then
        echo "$((diff / 3600))h ago"
    elif [[ $diff -lt 2592000 ]]; then
        echo "$((diff / 86400))d ago"
    elif [[ $diff -lt 31536000 ]]; then
        echo "$((diff / 2592000))mo ago"
    else
        echo "$((diff / 31536000))y ago"
    fi
}

# Build the selection list (projects only, no worktrees yet)
build_selection_list() {
    local selections=()

    # Search project directories (removed Dropbox)
    for dir in ~/work/* ~/config/* ~/personal/*; do
        [[ ! -d "$dir" ]] && continue

        # Fast check: skip numeric directories (likely worktrees)
        local basename=$(basename "$dir")
        if [[ "$basename" =~ ^[0-9]+$ ]]; then
            continue
        fi

        # Get modification time for sorting (do this once)
        local mtime=$(get_dir_mtime "$dir")

        # Skip time_ago calculation - it's expensive and not critical
        # We can add it back later if needed, but speed is priority

        # Check if it's a bare repo (fast with .bare marker)
        if [[ -f "$dir/.bare" ]] || [[ "$dir" == *.git ]]; then
            # Bare repo - show just the repo name (no branches)
            local repo_name=$(basename "$dir" | sed 's/\.git$//')
            selections+=("$mtime|BARE|$dir|$repo_name")
        # Check if .git exists (fast filesystem check)
        elif [[ -d "$dir/.git" ]] || [[ -f "$dir/.git" ]]; then
            # Git repository - get branch without spawning git process if possible
            local branch=""
            if [[ -f "$dir/.git/HEAD" ]]; then
                # Try to read branch from HEAD file directly (much faster)
                branch=$(grep "ref: refs/heads/" "$dir/.git/HEAD" 2>/dev/null | sed 's|ref: refs/heads/||')
            elif [[ -f "$dir/.git" ]]; then
                # Worktree - read gitdir and get branch from there
                local gitdir=$(grep "gitdir:" "$dir/.git" 2>/dev/null | sed 's/gitdir: //')
                if [[ -n "$gitdir" && -f "$gitdir/HEAD" ]]; then
                    branch=$(grep "ref: refs/heads/" "$gitdir/HEAD" 2>/dev/null | sed 's|ref: refs/heads/||')
                fi
            fi

            local display_name=$(basename "$dir")
            if [[ -n "$branch" ]]; then
                selections+=("$mtime|GIT|$dir|$display_name -> $branch")
            else
                selections+=("$mtime|GIT|$dir|$display_name")
            fi
        else
            # Regular directory (non-git)
            local display_name=$(basename "$dir")
            selections+=("$mtime|DIR|$dir|$display_name")
        fi
    done

    # Sort by modification time (most recent first)
    printf '%s\n' "${selections[@]}" | sort -t'|' -k1 -rn | cut -d'|' -f2-
}

# Build worktree selection list for a bare repo
build_worktree_list() {
    local bare_repo=$1
    local worktrees=()

    while IFS= read -r worktree_path; do
        [[ -z "$worktree_path" ]] && continue
        branch=$(get_branch "$worktree_path")
        local display=$(basename "$worktree_path")
        local mtime=$(get_dir_mtime "$worktree_path")
        local ago=""
        if [[ $mtime -gt 0 ]]; then
            ago=" ($(time_ago $mtime))"
        fi

        if [[ -n "$branch" ]]; then
            worktrees+=("$mtime|$worktree_path|$display -> $branch$ago")
        else
            worktrees+=("$mtime|$worktree_path|$display$ago")
        fi
    done < <(get_worktrees_from_bare "$bare_repo")

    # Sort by modification time (most recent last/at bottom)
    printf '%s\n' "${worktrees[@]}" | sort -t'|' -k1 -rn | cut -d'|' -f2-
}

# Main script
if [[ $# -eq 1 ]]; then
    selected_path=$1
else
    # Show FZF with formatted list (most recent at top, no sorting by fzf for speed)
    selected=$(build_selection_list | fzf --no-sort --delimiter='|' --with-nth=3 --tiebreak=index)

    if [[ -z $selected ]]; then
        exit 0
    fi

    # Extract type and path
    type=$(echo "$selected" | cut -d'|' -f1)
    path=$(echo "$selected" | cut -d'|' -f2)

    # If it's a bare repo, auto-select workspace 1
    if [[ "$type" == "BARE" ]]; then
        # Always select workspace 1 (first workspace)
        workspace_1="$path/1"

        if [[ ! -d "$workspace_1" ]]; then
            echo "No workspace 1 found for bare repo: $path"
            echo "Expected: $workspace_1"
            exit 1
        fi

        selected_path="$workspace_1"
    else
        selected_path=$path
    fi
fi

if [[ -z $selected_path ]]; then
    exit 0
fi

# Determine session name based on whether this is a worktree
# Check if parent directory is a bare repo
parent_dir=$(dirname "$selected_path")
if is_bare_repo "$parent_dir"; then
    # This is a worktree of a bare repo
    # Session name: <repo-name>_<branch-name>
    repo_name=$(basename "$parent_dir" | sed 's/\.git$//' | tr . _)
    branch=$(get_branch "$selected_path" 2>/dev/null)
    if [[ -n "$branch" ]]; then
        selected_name="${repo_name}_${branch}"
    else
        selected_name="${repo_name}_$(basename "$selected_path" | tr . _)"
    fi
else
    # Regular directory or regular git repo
    # Session name: just the directory name
    selected_name=$(basename "$selected_path" | tr . _)
fi

tmux_running=$(pgrep tmux)

# Create session if it doesn't exist
if [[ -z $TMUX ]] && [[ -z $tmux_running ]]; then
    tmux new-session -s "$selected_name" -c "$selected_path"
    exit 0
fi

if ! tmux has-session -t="$selected_name" 2>/dev/null; then
    # Create new session with first window (terminal only)
    tmux new-session -ds "$selected_name" -c "$selected_path"

    # Window 1: Split for Claude in right pane (70/30)
    # Run claude from selected directory (worktrees use .claude symlink for shared config)
    tmux split-window -t "$selected_name:1" -h -p 30 -c "$selected_path" "claude"

    # Create window 2 with nvim
    tmux new-window -t "$selected_name:2" -c "$selected_path"
    tmux send-keys -t "$selected_name:2" 'nvim .' C-m

    # Focus on window 1 (terminal + claude)
    tmux select-window -t "$selected_name:1"
fi

# Attach or switch
if [[ -z $TMUX ]]; then
    tmux attach-session -t "$selected_name"
else
    tmux switch-client -t "$selected_name"
fi

