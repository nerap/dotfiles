#!/usr/bin/env bash

# Function to check if a directory is a bare git repository
is_bare_repo() {
    local dir=$1
    [[ -d "$dir" ]] || return 1
    local result=$(git -C "$dir" rev-parse --is-bare-repository 2>/dev/null)
    [[ "$result" == "true" ]]
}

# Function to detect if directory is a git worktree
is_git_repo() {
    local dir=$1
    [[ -d "$dir" ]] || return 1
    git -C "$dir" rev-parse --is-inside-work-tree &>/dev/null
}

# Function to get branch name for a git directory
get_branch() {
    local dir=$1
    git -C "$dir" branch --show-current 2>/dev/null
}

# Function to get all worktrees from a bare repo
get_worktrees_from_bare() {
    local bare_repo=$1
    # Parse git worktree list --porcelain output
    # Skip the bare repo itself, only return actual worktrees
    git -C "$bare_repo" worktree list --porcelain 2>/dev/null | \
        awk '
            /^worktree/ { path = $2; has_path = 1 }
            /^bare$/ { has_path = 0 }
            /^$/ {
                if (has_path) print path
                has_path = 0
            }
            END { if (has_path) print path }
        '
}

# Get last modification time for git repo (for sorting)
get_git_mtime() {
    local dir=$1
    # Get timestamp of last commit (or 0 if not a git repo)
    local mtime=$(git -C "$dir" log -1 --format=%ct 2>/dev/null || echo "0")
    echo "$mtime"
}

# Convert timestamp to "X ago" format
time_ago() {
    local timestamp=$1
    local now=$(date +%s)
    local diff=$((now - timestamp))

    if [[ $diff -lt 60 ]]; then
        echo "${diff}s ago"
    elif [[ $diff -lt 3600 ]]; then
        echo "$((diff / 60))m ago"
    elif [[ $diff -lt 86400 ]]; then
        echo "$((diff / 3600))h ago"
    elif [[ $diff -lt 2592000 ]]; then
        echo "$((diff / 86400))d ago"
    elif [[ $diff -lt 31536000 ]]; then
        echo "$((diff / 2592000))mo ago"
    else
        echo "$((diff / 31536000))y ago"
    fi
}

# Build the selection list (projects only, no worktrees yet)
build_selection_list() {
    local selections=()

    # Search project directories (removed Dropbox)
    for dir in ~/work/* ~/config/* ~/personal/*; do
        [[ ! -d "$dir" ]] && continue

        # Skip if this is a worktree of a bare repo (will be handled by bare repo)
        parent_dir=$(dirname "$dir")
        if is_bare_repo "$parent_dir"; then
            # This directory is inside a bare repo, skip it
            # It will be listed when we select the bare repo itself
            continue
        fi

        # Get modification time for sorting
        local mtime=$(get_git_mtime "$dir")
        local ago=""
        if [[ $mtime -gt 0 ]]; then
            ago=" ($(time_ago $mtime))"
        fi

        # Check if it's a bare repo
        if is_bare_repo "$dir"; then
            # Bare repo - show just the repo name (no branches)
            local repo_name=$(basename "$dir" | sed 's/\.git$//')
            selections+=("$mtime|BARE|$dir|$repo_name$ago")
        elif is_git_repo "$dir"; then
            # Regular git repository - show with branch
            branch=$(get_branch "$dir")
            local display_name=$(basename "$dir")
            if [[ -n "$branch" ]]; then
                selections+=("$mtime|GIT|$dir|$display_name -> $branch$ago")
            else
                selections+=("$mtime|GIT|$dir|$display_name$ago")
            fi
        else
            # Regular directory (non-git)
            local display_name=$(basename "$dir")
            selections+=("$mtime|DIR|$dir|$display_name")
        fi
    done

    # Sort by modification time (most recent last/at bottom)
    printf '%s\n' "${selections[@]}" | sort -t'|' -k1 -rn | cut -d'|' -f2-
}

# Build worktree selection list for a bare repo
build_worktree_list() {
    local bare_repo=$1
    local worktrees=()

    while IFS= read -r worktree_path; do
        [[ -z "$worktree_path" ]] && continue
        branch=$(get_branch "$worktree_path")
        local display=$(basename "$worktree_path")
        local mtime=$(get_git_mtime "$worktree_path")
        local ago=""
        if [[ $mtime -gt 0 ]]; then
            ago=" ($(time_ago $mtime))"
        fi

        if [[ -n "$branch" ]]; then
            worktrees+=("$mtime|$worktree_path|$display -> $branch$ago")
        else
            worktrees+=("$mtime|$worktree_path|$display$ago")
        fi
    done < <(get_worktrees_from_bare "$bare_repo")

    # Sort by modification time (most recent last/at bottom)
    printf '%s\n' "${worktrees[@]}" | sort -t'|' -k1 -rn | cut -d'|' -f2-
}

# Main script
if [[ $# -eq 1 ]]; then
    selected_path=$1
else
    # Show FZF with formatted list
    selected=$(build_selection_list | fzf --delimiter='|' --with-nth=3)

    if [[ -z $selected ]]; then
        exit 0
    fi

    # Extract type and path
    type=$(echo "$selected" | cut -d'|' -f1)
    path=$(echo "$selected" | cut -d'|' -f2)

    # If it's a bare repo, auto-select most recent worktree
    if [[ "$type" == "BARE" ]]; then
        # Get most recent worktree (first line from sorted list)
        worktree_selected=$(build_worktree_list "$path" | head -1)

        if [[ -z $worktree_selected ]]; then
            echo "No worktrees found for bare repo: $path"
            exit 1
        fi

        selected_path=$(echo "$worktree_selected" | cut -d'|' -f1)
    else
        selected_path=$path
    fi
fi

if [[ -z $selected_path ]]; then
    exit 0
fi

# Determine session name based on whether this is a worktree
# Check if parent directory is a bare repo
parent_dir=$(dirname "$selected_path")
if is_bare_repo "$parent_dir"; then
    # This is a worktree of a bare repo
    # Session name: <repo-name>_<branch-name>
    repo_name=$(basename "$parent_dir" | sed 's/\.git$//' | tr . _)
    branch=$(get_branch "$selected_path" 2>/dev/null)
    if [[ -n "$branch" ]]; then
        selected_name="${repo_name}_${branch}"
    else
        selected_name="${repo_name}_$(basename "$selected_path" | tr . _)"
    fi
else
    # Regular directory or regular git repo
    # Session name: just the directory name
    selected_name=$(basename "$selected_path" | tr . _)
fi

tmux_running=$(pgrep tmux)

# Create session if it doesn't exist
if [[ -z $TMUX ]] && [[ -z $tmux_running ]]; then
    tmux new-session -s "$selected_name" -c "$selected_path"
    exit 0
fi

if ! tmux has-session -t="$selected_name" 2>/dev/null; then
    # Create new session with first window (terminal only)
    tmux new-session -ds "$selected_name" -c "$selected_path"

    # Window 1: Split for Claude in right pane (70/30)
    tmux split-window -t "$selected_name:1" -h -p 30 -c "$selected_path" "claude --continue || claude"

    # Create window 2 with nvim
    tmux new-window -t "$selected_name:2" -c "$selected_path"
    tmux send-keys -t "$selected_name:2" 'nvim .' C-m

    # Focus on window 1 (terminal + claude)
    tmux select-window -t "$selected_name:1"
fi

# Attach or switch
if [[ -z $TMUX ]]; then
    tmux attach-session -t "$selected_name"
else
    tmux switch-client -t "$selected_name"
fi

